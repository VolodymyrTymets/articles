# REST API пришвидшення роботи або надлишок даних та як із ним боротися
Не так давно я став інтересуватися технологіює Gqrap Ql. Нова ідея новий підхід при обміні даних клієнтів і серверів, все це здорово і приємно чути що технології не стоять на місці. Я глянув кілька вступихн уроків і там завжди наводився один приклад з переваг Gpaph Ql над REST API те що при REST діходів клієнт нагружений надлишком даних і це зменшує швиткодію додатку. І тут я сатв задумуватися над цим питанням "Невже його не можливо вирішити". Аже ж не завжди можна так різко поміняти технологію. Існують  старі проекти які тяжко і затратно перевести на Graph Ql. Тай не завжди це доцілльно. Як вже два роки пишу REST API на Express JS + Mongo тому вирішив розібратися в цій проблемі і поділиться своми ідеями у цій статті. Усі приклади і рішення орієнтовані на стек технологій  Express JS + Mongo + js (on client) проте думаю основна ідея підійде для будь яких технологій. 


## Проблема 1 Отримую більше ніж замовляв
Припустимо що  у системі є сутність `User`. У цього користувача є опширний профіль з n кількісю полів. Детальний опис користувача, як особистості. Припустимо імя прізвище адреса нмер телефону якась додаткова інформація. А якщо система містить інтенграцію з сервісами то у вас появляється ще додаткові поля типу  `services`. І тепер на клієнті вам потрібний простий автокомпліт по користувачам. Потрібно найти конкретного користувача по імені і передати його `id` далбше по ситемі. 
Щоб вирішити дану задачу ми напевне напишемо якись роут типу `api/v1/users?serch='Richard'`. По ідеї він нам верне всіх користувачів з імям `Richard`. Але от не задача він вернув нам весь обєкт  `User`.  
```
{
   _id: 1,
   profile: {
     firstName,
     lastName,
     address,
     ....
     phone,
   }, 
   servicess: { ... }
}
```

Но для того щоб відобразити наш автокомпліт нам достаттньо лиш полів `fisrtNmae` and `lastName`. Для чого нам зайві дані, чим бульше даних тим довша їх передача. А ящо у вас іде розробка апі для мобільних платформ у яких можливий повільний інтернет то це стає проблемою. 
### Вирішення
Перша думка яка приходить у голову це написати новий роут  `api/v1/users/for-autocompete`, але чим більше роутів тим більше ваші апі тому це не дуже хороша практика. А рішення насправді досить просте і тривіальне. У нас же є query param `search` то чому б не додати  ще один типу `fields`. Він відповідатиме за вибірку полів які вам потрібно де `1` вказуватиме на те що це поле yfv потрібно а `-1` на те що вам його не потрібно. Тепер звернення до апі виглядатиме наступним чином `api/v1/users?serch=Richard&fields.profile.firstName=1&fields.profile.firstName=1`
На перший погляд така строка запиту виглядає трохи дивно і ви можете подумати що її формувати це ще той головний біль. Тай навіщо мені це. Насправді ж ні це все досить зручно. Вам достатньо написати який хелпер типу `qeury` or `withQuery` який генеруватиме вам вашу строку параметрів.
```
const toString = v => (_.isDate(v) && v.toISOString()) || v;
const isObject = (v) => {
  if (_.isDate(v)) {
    return false;
  }
  return _.isObject(v);
};

const query = (data, fields = {}) => {
  const toQueryParam = (obj, prevName = '') =>
    _.keys(obj).map(key =>
      (isObject(obj[key]) && toQueryParam(obj[key], `${prevName}${key}.`)) ||
      `${prevName}${key}=${toString(obj[key]) || ''}`);

  const objAsParams = _.flatten(toQueryParam(data)).join('&');
  const fieldsAsParams = _.flatten(toQueryParam(fields)).join('&');
  const separator = !_.isEmpty(fields) && '&' || '';

  return `?${objAsParams}${separator}${fieldsAsParams}`;
};
```

> Тут використано різні типи перевірок Оскільки дату у вебі слід відправляти в ISO форматі.

Тепер можна потестити наш чарівний метод:
```
console.log(query({ limit: 10, from: new Date('12/12/2012') }));
console.log(query({ limit: 10 }, { profile: { firstName: 1 } }));
console.log(query({ limit: 10 }, { 'profile.firstName': 1 }));
```
І отримати потрібний результат
```
?limit=10&from=2012-12-11T22:00:00.000Z
- - - - - - - - - - - - - - - - - - 
?limit=10&profile.firstName=1
- - - - - - - - - - - - - - - - - - 
?limit=10&profile.firstName=1

```

Пепер при любих запитах до любих сутностей ви зможете формувати запити на потрібні вам дані у досить зручний спосі.
```
get(`api/v1/users${query({ searsh: 'Richard'}, { profile: { firstName: 1, lastName: 1 } })}`)

or 
get(`api/v1/users${query({ searsh: 'Richard'}, 'profile.firstName profileLastName')}`)
```

Ну щож тепер пора поговрити про наше АПІ. __Основна ідея полягає щоб розпарсити наш обєкт `fields` із query params та відфільтрувати ті поля сутності які вказав користувач АПІ.__ Якшо ж він не вказав їх то вернути весь обєкт. Нижче наведена невеличка реалізвція цієї ідеї на Express js 
Припустимо у нас є роут є `users`. Перш за все з нього нам потрібно вибрати поле `fields`.
```
api.get('/', (req, res, next) => {
const { fields } = req.query; // <-magick here 
})
```
Насправді магії не відбудеться. Нам прийде обєкт такого типу. 
```
{ 
  'search': 'Richard',
  'fields.profile.firsttName': '1',
  'fields.profile.LastName': '-1',
}
```
Отже нам потрібно дописати якись хелпер який дозволить витягнути наш обєкт `fields` 
from `query` до тогож відділивший його від інших параметрів. Але цей метод нам пригодиться також у всіх інхих запитах тому краще це описати у вигляді `midllware`.

```
const queryToObject = query => {
  const obj = {};
  _.keys(query).forEach(key => _.set(obj, key, query[key]));
  return obj;
};

const withFields = (req, res, next) => {
  const query = queryToObject(req.query); // <- parse query to { search, profile: {...}  }
  const fields = DataObjectParser.untranspose(query.fields); // back fields to { 'profile.firstName': '-1' }
  _.keys(fields || {}).forEach(key =>
    _.extend(fields, { [key]: parseInt(fields[key]) })); // parse to Int
  _.extend(req, { fields });
  next();
};
```
> Усі вищезазначенні маніпуляції з обєктом приходиться робити саме для монго. Ваша ж реалізація може бути докорінно іншою.

Тепер ми мложемо використовувати наш `withFields` для кожного роута і бути впевненими що матимемо достув до `req.fields`. Наступним кроком є вибірка і фільтрація самих даних. На щастя монго вже все зробив за нас. У ній є чудовий підхід [Projections](https://docs.mongodb.com/manual/reference/method/db.collection.find/#projections) який ми і використаємо.

```
api.get('/', withFields, async (req, res, next) => {
 const users = await User.find({ }, req.fields);
 res.status(200).send({ users });
});
api.get('/:_id', withFields, ...);
```
Тепер при наявносіті в запиті поля `fields` монго а відповідно і на роут поверне фідфільтровані поля. При його ж відсутності повернуться усі поля.  Таким чином ми отримали універсальну можливість фільтрувати напряму з клієнта ті поля які нам необхідні. При чому даний підхід підходить ло всіх запитів типу `GET` для усіх сутностей вашого API.

## Проблема 2 Навіщо стільки викликів?
Допустимо що у нашій системі  користувачі  належать до певної органцізації. Нам слід відображати цю оргацізацію для кожного користувача у списку. Але наші сутності розділенні. Тобто ми зберігаємо користувача у окремій колекці
ї (таблиція залежно від бд) Приблизно ось так:
Отже що нам для цього слід зробити? Перше що приходить в голову це спершу дістати список користувачів а тоді вже маючи `organizationId` отримати організацію.  
```
GET -> api/v1/users
GET -> api/v1/organization/_id
```
 Проблема тут в тому, що для того щоб відобразити одного користувача у списку вам слід робити додатковий запит. А якщо цих відношень буде кілька запити тільки множитимуться. А кожне звернення до сервера це додаткова затримка.
 
 ### Вирішення
А що якщо повертати усі дані в одному запиті. Якщо у вас є якась залежність в обєкті повертайте її а не тільки `forigenKye`.  Більшість даз даних дозволятю це робити то чому б не заставити це робите ваше API.
## Висновки


